import {readFileSync, writeFileSync} from 'fs';

const segprops_a = readFileSync("GraphemeBreakProperty.txt", "ASCII")
      .split('\n')
      .filter(x => !!x && !/^#/.test(x))
      .map(s => s.match(/^([0-9A-F]+)(?:..([0-9A-F]+))?\s+;\s([a-zA-Z]*).*$/))
      .map(([_,a,b,x]) => [parseInt(a, 16), b && parseInt(b, 16), x])
      .reduce((acc, [a, b, x]) => {
        if(!acc[x]) acc[x] = [];
        acc[x].push([a, b ? b - a : 0]);
        return acc;
      }, {});

const segprops_b = {};

const fnil = (f, d) => (x, ...args) => x ? f(x, ...args) : f(d, ...args);

const update = (m, k, f, ...addargs) => {
  m.set(k, f(m.get(k), ...addargs))
  return m;
}

for (const [k, vs] of Object.entries(segprops_a)) {
  const lemap = vs.reduce(
    (acc, [a, o]) => update(acc, o, fnil(x => [...x, a], [])),
    new Map());

  segprops_b[k] = [...lemap.entries()];
};

const segprops_c = [];

const propenums = {
  Prepend: 1,
  CR: 2,
  LF: 3,
  Control: 4,
  Extend: 5,
  Regional: 6,
  SpacingMark: 7,
  L: 8,
  V: 9,
  T: 10,
  LV: 11,
  LVT: 12,
  ZWJ: 13
};

for (const [k, v] of Object.entries(segprops_b)) {
  segprops_c.push([propenums[k], v]);
}

const segprops_d = [];

{
  for (const [p, mr] of segprops_c)
    for (const [s, bs] of mr)
      segprops_d.push([p, s, bs])
}

let maxcp = 0;
for (const [p, s, bs] of segprops_d)
  for (const b of bs)
    for (let c = b; c <= (b + s); c++)
      maxcp = Math.max(maxcp, c);


writeFileSync(
  "GraphemeBreakProperty.js",
  `// Generated by prep.js
const GraphemeBreakProperty = JSON.parse(${(JSON.stringify(JSON.stringify(segprops_d)))});
const lut = new Uint8Array(${Math.ceil(maxcp / 2)});

for (const [p, s, bs] of GraphemeBreakProperty)
  for (const b of bs)
    for (let c = b; c <= (b + s); c++)
      lut[c >> 1] |= ((c & 1) ? p << 4 : p);

export const classify = c => {
  const v = lut[c >> 1];
  if (!v) return 0;
  else if (c & 1) return v >> 4;
  else return v & 0xF;
}
`);
